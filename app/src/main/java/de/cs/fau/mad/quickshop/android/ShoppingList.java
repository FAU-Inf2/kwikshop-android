package de.cs.fau.mad.quickshop.android;

import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.field.ForeignCollectionField;
import com.j256.ormlite.table.DatabaseTable;

import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.Vector;

@DatabaseTable(tableName = "shoppingList")
public class ShoppingList {

  /** 
   *  unique id generated by storage
   */
  @DatabaseField(id = true)
  private int id;

  /**
   *  not unique, can be set by user
   */
  @DatabaseField(canBeNull = false)
  private String name;

  /**
   * type: Account.id
   */
  @ForeignCollectionField
  private Collection<AccountID> sharedWith;

  @ForeignCollectionField
  private Collection<Item> items = new LinkedList(); // TODO: is Collection fine for everyone?

  private ListStorage storage;
  private Account owner;

  private enum visibility {
    PRIVATE
  }
  @DatabaseField(unknownEnumName = "PRIVATE")
  private visibility vis;


  public ShoppingList(int id) {
    this.id = id;
  }

  public ShoppingList() {
      // Default no-arg constructor for generating Items, required for ORMLite
  }

  public int getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Collection getSharedWith() {
    return sharedWith;
  }

  public visibility getVisibility() {
    return vis;
  }

  public void setVisibility(visibility visibility) {
    this.vis = visibility;
  }

  public Boolean save() {
    return storage.saveList(this);
  }

  public Boolean delete() {
    return storage.deleteList(this.getId());
  }

  public void addItem(Item item) {
    this.items.add(item);
  }

  public void removeItem(int id) {
    Iterator<Item> iterator = items.iterator(); // TODO: again: I hope a normal Iterator instead of a ListIterator is fine for everyone

    while (iterator.hasNext()) {
      Item currentItem = iterator.next();
      if(currentItem.getId() == id) {
        items.remove(currentItem);
        return;
      }
    }
  }


  public Collection<Item> getItems() {
    return Collections.unmodifiableCollection(this.items);
  }

}
