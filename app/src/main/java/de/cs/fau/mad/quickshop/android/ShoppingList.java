package de.cs.fau.mad.quickshop.android;

import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.field.ForeignCollectionField;
import com.j256.ormlite.table.DatabaseTable;

import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.Vector;

@DatabaseTable(tableName = "shoppingList")
public class ShoppingList {

  /** 
   *  unique id generated by storage
   */
  @DatabaseField(id = true)
  private int id;

  /**
   *  not unique, can be set by user
   */
  @DatabaseField(canBeNull = false)
  private String name;

  /**
   * Date of an Event for Calendar Usage
   */
  @DatabaseField(foreign = true, canBeNull = true)
  private CalendarEventDate eventDate = new CalendarEventDate();

  /**
   * type: Account.id
   */
  @ForeignCollectionField
  private Collection<AccountID> sharedWith;

  @ForeignCollectionField
  private Collection<Item> items = new LinkedList(); // TODO: is Collection fine for everyone?

  private ListStorage storage;
  private Account owner;

  private enum visibility {
    PRIVATE
  }
  @DatabaseField(unknownEnumName = "PRIVATE")
  private visibility vis;


  public ShoppingList(int id) {
    this.id = id;
  }

  public ShoppingList() {
      // Default no-arg constructor for generating Items, required for ORMLite
  }

  public int getId() {
    return id;
  }

  public String getName() { return name; }

  public void setName(String name) { this.name = name; }

  public CalendarEventDate getCalendarEventDate() {return eventDate; }

  public void setCalendarEventDate(CalendarEventDate eventDate){this.eventDate = eventDate; }

  public Collection getSharedWith() {
    return sharedWith;
  }

  public visibility getVisibility() {
    return vis;
  }

  public void setVisibility(visibility visibility) {
    this.vis = visibility;
  }

  public Boolean save() {
    return storage.saveList(this);
  }

  public Boolean delete() {
    return storage.deleteList(this.getId());
  }

  public void addItem(Item item) {
    this.items.add(item);
  }

  public void removeItem(int id) {
    Iterator<Item> iterator = items.iterator(); // TODO: again: I hope a normal Iterator instead of a ListIterator is fine for everyone

    while (iterator.hasNext()) {
      Item currentItem = iterator.next();
      if(currentItem.getId() == id) {
        items.remove(currentItem);
        return;
      }
    }
  }

  public void removeItem(Item item) {
    Iterator<Item> iterator = items.iterator();

    while (iterator.hasNext()) {
      Item currentItem = iterator.next();
      if(currentItem.getId() == item.getId()) {
        items.remove(currentItem);
        return;
      }
    }
  }

  public void updateItem(Item item) {
    removeItem(item);
    addItem(item);
  }

  public Collection<Item> getItems() {
    return Collections.unmodifiableCollection(this.items);
  }

  public Item getItem(int id) {
    for(Item item : items) {
      if(item.getId() == id) {
        return item;
      }
    }
    return null;
  }
}
